---
title: 함수형 프로그래밍 시작하기 (6)
tags: FP
key: post-hello-fp-6
---

### 커링(Currying)

커링은 여러 인자를 취하는 함수를 하나의 인자를 취하는 함수의 나열 형태로 바꾸는 기술입니다.<br>
커링은 실용적인 면이나 이론적인 면 모두에서 유용한 기술로<br>
이론 컴퓨터 과학에서는 하나의 인자 만을 가지는 모델을 다인자를 가지는 복합 모델로 만드는데 이론적 토대를 제공합니다.<br>
프로그래밍 분야에서는 인자나 예외의 전달을 간편하게 해 줌은 물론,<br> 
데이터의 생성과 그 데이터를 활용 시점을 분리할 수 있도록 도와주는 이점이 있습니다.<br>
이에 대해 예제와 함께 간략히 알아보도록 하겠습니다.<br>

---

하스켈에서 함수는 기본적으로 커링화 되어 있습니다.<br>
하스켈의 모든 함수는 1인자 함수이며 여러 인자를 가지는 함수라고 하더라도,<br>
하나의 인자를 받아 또 다른 함수를 반환하는 1인자 함수일 뿐입니다.<br>
```
someFunc :: String -> Int -> Int
```

하스켈 함수 시그니쳐의 모양이 위와 같은 것도 커링화 되어 있기 때문입니다.<br>
이번 포스트에서는 이전과는 다르게 하스켈이 아닌 다른 언어(코틀린)을 사용하여<br>
커링의 동작과 구현에 대해 알아보도록 하겠습니다.<br>

```
fun something(a: A, b: B, c: C) : D // 다인자 함수
// something(1, 2, 3)
fun curryed(a: A) : (B) -> ((C) -> D) // 커링된 함수
// curryed(1)(2)(3)
```

![그림1 커링](https://codeherb.github.io/assets/images/img_example_curry.jpeg)

위의 그림과 같이 커링을 이용하면 제공 가능한 인자만 적용하고 함수의 평가는 지연하는 `Lazy Evaluation`을 쉽게 사용할 수 있습니다.<br>
(함수의 인자가 몇개가 되었든 함수의 실행을 마지막 인자가 주어질 때 까지 뒤로 미룰 수 있으며, 특정 값으로 고정한체 함수를 재활용 할 수 있다.)<br>
<br>
커링의 개념을 엄밀하게 따지자면 커링/언커링이 성립하기 위해서는 일반적으로 시스템이 `닫힌 모노이드 카테고리`를 이루어야 합니다.<br>
이는 카테고리 이론과 관련된 주제이며 하스켈 타입 클래스와도 관계가 깊으나, 벼의 유전자 구성 따위 몰라도 우리가 밥을 해 먹을 수 있듯,<br>
프로그래밍 언어들은 대부분 닫힌 구조를 이루고 있으므로 대부분의 언어에서 커링을 할 수 있다고 생각해도 무방합니다.<br>
(조금 아는 체를 하고 싶으면 ‘닫힌 모노이드 카테고리’를 이루어야 한다고 하면 오오! 하는 감탄사를 들을 수 있다.)<br>
<br>
일부 언어는 함수가 항상 커링되어 있습니다. ML 이나 Haskell 이 그 예 입니다.<br>
이 두 언어는 모두 람다대수에 그 뿌리를 두고 있으며, 람다 대수에서 함수는 인자를 단 한 개 받을 수 있고<br>
함수가 또 다른 함수를 반환하는 함수의 나열을 통해 다인자 함수를 구현합니다.<br>
ML계열 언어나 Haskell은 이 속성이 그대로 이어 받은 것이라고 볼 수 있습니다.<br>

```
ℷ x. 2x           <— 1인자 함수 (아는 체 하고 싶다면 unary function 이라고 해보자)
ℷ x . ℷ y .x * y  <— 다중 인자 함수
```
하스켈이나 ML계열 언어가 아닌 일반 프로그래밍 언어에서 커링을 구사하기 위해서는 몇 가지 테크닉이 필요합니다.<br>
그것은 바로 클로저(Closure)와 부분적용 (Partial Application) 입니다.<br>
클로저는 함수에서 사용하는 자유 변수에 값을 모종의 방법으로 특정 값으로 바인딩 하는 기술이고<br>
(자유 변수 : 함수의 인자 혹은 지역 변수로 정의되지 않은 변수로 함수의 외부 스코프로 부터 값을 제공받는 변수)<br>
부분 적용은 클로저의 응용 기술로 클로저를 이용하여 함수의 다중 인자 중 일부에 값을 부여하는 기술 입니다.<br>
```
fun doSomething(a: A, b: B, c: C) {
    ….
}
// 부분 적용
doSomething.partialApply(instA)(instB, instC)
```
사실 함수의 인자가 두개인 경우에는 커링과 차이를 느낄 수 없습니다.<br>
하지만 인자가 3개 이상인 경우 부분 적용의 경우 후속 함수에 나머지 인자를 제공하여야 하지만<br>
커링 된 함수의 경우 마지막 인자에 도달하기 까지 1개의 인자만 제공하며 여러 값으로 고정된<br>
함수를 만들고 재사용 할 수 있습니다.<br>
```
// 코틀린의 확장 함수를 이용한 부분 적용 구현 
// 임의의 인자에 대해 적용 가능하게 제네릭으로 구성
fun <P1, P2, R> ((P1, P2) -> R).partialApply(x: P1): (P2) -> R 
{
    return { p2 -> this(x, p2) }        // 클로저에 의해 x 값이 고정된체 함수 타입을 반환
}

// 코틀린의 확장 함수를 이용한 커링의 구현
// 임의의 인자에 대해 적용 가능하게 제네릭으로 구성
fun <P1, P2, P3, R> ((P1, P2, P3) -> R).curried() : (P1) -> (P2) -> (P3) -> R 
{
    p1: P1 -> { p2: P2 -> { p3: P3 -> this(p1, p2, p3) } }  // 함수에 인자가 주어지면 후속 함수의 자유변수를 클로징 함(평가 지연 효과)
}
```
> 확장 함수는 코틀린의 편리 기능 중 하나로 외부에서 특정 클래스의 멤버 함수와 같이 동작하는 함수를 정의할 수 있게 해주는 기능입니다. 
> 다른 언어에서 구현하고자 한다면 함수의 첫번째 인자로 내부에서 사용하고자 하는 클래스의 인스턴스를 받는 함수를 정의하는 형태로 대체 가능합니다.

