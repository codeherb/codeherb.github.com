---
title: 함수형 프로그래밍 시작하기 (7)
tags: FP
key: post-hello-fp-7
---

## 평가 전략 (Evaluation Strategy)

평가 전략(evaluation strategy)이란 식을 어떻게 해석할 지에 대한 순서와 규칙들을 의미한다.<br>
크게 평가 전략에는 적극 평가 (Eager Evaluation), 지연 평가 (Lazy Evaluation)로 구분 할 수 있고<br>
대다수의 언어들은 적극 평가를 기본으로 하지만, 하스켈은 지연 평가를 기본 전략으로 채용하고 있다.<br>
이 둘 간의 차이를 알아보고 실제 하스켈에서의 예를 살펴보자.<br>

---

## 적극 평가(Eager Evaluation)
적극 평가 혹은 엄격 평가(Strict Evaluation)은<br>
전통적 프로그래밍 언어에서 흔히 사용하는 계산 전략으로 수식은 변수에 접근하는 순간 계산된다.<br>
함수의 인수로 수식을 전달 할 경우, 함수 호출 이전에 평가가 이루어진다.<br>
```
// 변수는 선언과 동시에 후속 식의 평가 결과로 초기화 된다.
int page = total / pageCount + (total % pageCount != 0 ? 1 : 0)
// f를 평가 하기 위해 인자를 먼저 평가한다.
f(g1(), g2(), g3())
```
적극 평가를 사용할 경우 모든 변수, 함수의 인자 등은<br>
평가가 완료된 상태로 전달되므로, 계산되지 않은 수식 등을<br>
보존 할 별도의 자료구조 등이 필요 없으며, 메모리 효율이나<br>
속도 면에서 우수한 특성을 가지고 있어 많은 언어에서 사용하는 평가 전략이다.<br>

## 지연 평가(Lazy Evaluation)
지연 평가는 쉽게 말하자면 계산의 결과를 사용할 때까지 계산하지 않는 전략이다.<br>
계산이 느긋하게 이루어지면서 필요 없는 계산을 하지 않으므로 효율적으로 실행 가능하며,<br>
이러한 특성은 복합수식 계산시 오류에 대한 저항성을 높여준다.<br>
(모든 식은 잠재적 오류를 가지고 있는데, 필요없는 식은 실행하지 않기 때문)<br>
또한 무한 자료구조를 생성 가능하며, 함수 자체를 제어구조로 구성할 수 있다.<br>

그럼 지연 평가의 특성을 잘 보여주는 예시를 몇 가지 알아보자.<br>

## 단락 평가(short-circuit evaluation)
사실 C나 JAVA같은 적극 평가를 사용하는 프로그래밍 언어에서도<br>
지연 평가와 유사한 평가 전략을 사용하고 있는 곳이 있다.<br>
바로 &&, || 같은 논리 연산을 사용할 때이다.
```
if (isLogin() && isAdult())
```
위와 같은 논리식이 있을 때 컴파일러 혹은 인터프리터는 식에 있는 모든 단락을 평가하지 않는다.<br> 
만약 위의 isLogin()의 결과가 False라면 두번째 단락의 평가 결과에 관계 없이<br> 
&& 연산의 결과는 False 이므로 평가 하지 않고 거짓으로 결정한다.<br> 
이러한 평가 전략을 단락 평가(short-circuit evaluation) 라고 한다.<br>

## 하스켈에서의 평가 살펴 보기
하스켈에서 지연 평가는 위와 같은 단락 평가의 특징에 패턴 매칭이 더 해져 독특한 평가 형태를 띈다.<br>
하스켈에서의 피보나치 함수가 어떤 절차로 평가 되는지 살펴보자.<br>
```
fibs :: [Integer]
fibs = 1 : 1 : zipWith (+) fibs (tail fibs)

 > fibs
     => 1 : 1 : zipWith (+) (1 : 1 : zipWith (+) fibs (tail fibs)) (tail fibs)
     => 1 : 1 : zipWith (+) (1 : 1 : zipWith (+) fibs (tail fibs)) (tail (1 : 1 : zipWith (+) fibs (tail fibs)))
     => 1 : 1 : zipWith (+) (1 : 1 : zipWith (+) fibs (tail fibs)) (1 : zipWith (+) fibs (tail fibs))
     => 1 : 1 : 2 : zipWith (+) (1 : zipWith (+) fibs (tail fibs)) (zipWith (+) fibs (tail fibs))
     => 1 : 1 : 2 : zipWith (+) (1 : zipWith (+) fibs (tail fibs)) (zipWith (+) (1 : 1 : zipWith (+) fibs (tail fibs)) (tail fibs))
     => 1 : 1 : 2 : zipWith (+) (1 : zipWith (+) fibs (tail fibs)) (zipWith (+) (1 : 1 : zipWith (+) fibs (tail fibs)) (tail (1 : 1 : zipWith (+) fibs (tail fibs))))
     => 1 : 1 : 2 : zipWith (+) (1 : zipWith (+) fibs (tail fibs)) (zipWith (+) (1 : 1 : zipWith (+) fibs (tail fibs)) (1 : zipWith (+) fibs (tail fibs)))
     => 1 : 1 : 2 : zipWith (+) (1 : zipWith (+) fibs (tail fibs)) (2 : (zipWith (+) (1 : zipWith (+) fibs (tail fibs)) (zipWith (+) fibs (tail fibs))))
     => 1 : 1 : 2 : 3 : zipWith (+) (zipWith (+) fibs (tail fibs)) ((zipWith (+) (1 : zipWith (+) fibs (tail fibs)) (zipWith (+) fibs (tail fibs))))
     …..
```
피보나치 수열은 대표적인 무한 수열이다.<br>
피보나치 함수 정의에서 볼 수 있듯이 재귀적으로 정의되어 있다.<br>
위의 평가 절차를 살펴 보면 몇가지 특징적인 점을 볼 수 있다.<br>
함수의 최종 실행 결과가 아닌 함수의 본문 자체가 평가 결과로서 전달되며<br>
패턴 매칭을 하여 값을 바로 취득할 수 있을 때는 추가적인 평가 없이<br>
다음 연산이 이루어진다는 점이다.<br>
<br>
앞서 지연평가는 주어진 식을 계산하고 결과를 얻는 평가(evaluation)를 언제 계산하고 언제 멈출지..<br>
함수에 이르러 서는 인수를 언제 평가하고 건낼 지를 결정하는 평가 전략의 일종이라고 하였다.<br>
이러한 전략은 당연히 하나가 아닌 여러 전략이 합쳐저 이루어진다.<br>
이에 대해 자세히 알아보고, 하스켈은 어떤 전략을 취하는지 조금 더 자세히 알아보자.<br>

## 정규순서 (normal order)
함수형 언어의 이론적 배경은 람다 대수이다.<br>
람다 대수는 복잡한 식으로 부터 참/거짓을 판별할 수 있게 하는 것이 목적이다.<br>
이를 위해 축약(reduction)이라고 부르는 식의 단순화 과정을 거친다.<br>
식의 평가 결과는 축약을 통한 단순화를 더이상 단순화 할 수 없을 때까지 한 결과이다.<br>
그 중 가장 직관적이고 간단한 축약 전략이 바로 `정규순서(normal order)`이다.<br>
방법은 다음과 같다.<br>
- `가장 왼쪽에 있는 것 부터`
- `가장 바깥에 있는 것 부터`
```
// 가장 왼쪽 바깥쪽 (\x -> (\y -> x)) 1 부터 축약
(\x -> (\y -> x)) 1 ((\x -> x x) (\x -> x x)) 
// 다시 가장 왼쪽 바깥쪽 축약에 반복
(\y -> 1) ((\x -> x x) (\x -> x x))
// 더 이상 축약할 수 없으므로 멈춘다.
1
```
축약 방법에 의해 (\x -> x x) (\x -> x x) 식은 전혀 평가 되지 않고 있음을 볼 수 있다.<br>
이와 같은 축약 방법을 줄여 leftmost outermost reduction 이라고 부르며,<br>
정규 순서에 의해 축약되어 더이상 축약할 수 없는 형태를 정규형(normal form) 이라 부른다.<br>
가장 기본적인 전략이며, 이 전략으로 축약 되지 않는 식은 <br>
다른 어떤 축약 방법으로도 축약할 수 없는 것으로 알려져 있다.<br>
<br>
사실 적극 평가와 지연 평가를 구분하는 차이는 이 축약 순서의 차이라고 할 수 있다.<br>
적극 평가는 맨 안쪽에 있는 것을 먼저 축약 한다면, 지연 평가는 가장 바깥 쪽에 있는 것을 먼저 축약한다.<br>
이런 차이는 적극 평가 시 함수 호출 시점에 인자로 넘어가는 값이 평가 완료된 상태(정규형)가 되는 특징을 가지게 한다.<br>
반대로 지연 평가의 경우 함수의 인자로 평가 되지 않은 식이 넘어갈수도 있다.<br>

## WHNF (weak head normal form)
하스켈은 람다 대수 보다도 더 적극적으로 지연 평가 전략을 사용한다.<br>
이를 위해 축약을 멈추는 시점에 제한을 두었는데 그것이 WHNF 이다.<br>
하스켈은 정규 순서에 의해 축약하되 식이 WHNF(weak head normal form) 형태가 될 때 축약을 멈춘다.<br>
WHNF 형태의 조건은 다음과 같다.

- `식의 가장 바깥이 값 생성자인 식`
- `식의 가장 바깥이 람다 표현식인 식`

이 기준에 의하면 람다 표현식 내의 식 들은 WHNF 이므로 더이상 평가 하지 않으며<br>
Just (1 + 2) 에서 (1 + 2) 또한 선두에 Just라는 값 생성자가 존재하므로 평가 되지 않는다.<br>
반대로 `(\x -> x + 1) 1` 과 같은 경우 함수를 적용할 인자를 가지므로 WHNF가 아니므로 평가가 이루어진다.<br>
축약시 WHNF 조건을 사용하면 데이터 구조의 평가와 데이터 구조 안의 값의 평가 시점을 분리되는 효과가 있어<br>
정규형을 사용했을 때 해야했던 연산 보다 더 불필요한 연산을 줄일 수 있다.<br>
<br>
이제 리스트의 평균을 구하는 함수의 평가 예시를 통해 더 자세히 알아보자.
```
mean’ :: [Double] -> Double
mean’ xs = let (res, len) = foldl (\(m, n) x -> (m + x / len, n + 1)) (0, 0) xs in res
```
위의 함수를 다음과 같이 실행 하였다고 가정해 보자.<br>
```
> mean’ [1 .. 4]
```
함수는 본문의 정의에 의해 즉시 다음과 같은 식으로 대체될 것이다.
```
> let (res, len) = foldl (\(m, n) x -> (m + x / len, n + 1)) (0, 0) [1, 2, 3, 4] in res
```
이 식에서 최종 목표는 res를 반환하는 것이고 이를 위해서 우리는 foldl 연산을 평가할 필요가 있다.<br>
foldl은 (0, 0) 과 [1, 2, 3, 4]으로 부터 값을 취해 람다식에 결과를 취하려 할 것이다.<br>
```
foldl :: (b -> a -> b) -> b -> [a] -> b
foldl _ v [] = v
foldl f v (x:xs) = foldl f (f v x) xs
```
위의 foldl의 정의와 패턴 매칭의 결과 다음과 같이 확장 가능할 것이다.
```
> let (res, len) = foldl (\(m, n) x -> (m + x / len, n + 1)) ((\(m, n) x -> (m + x / len, n + 1)) (0, 0) 1) [2, 3, 4] in res
> let (res, len) = foldl (\(m, n) x -> (m + x / len, n + 1)) (0 + 1 / len, 0 + 1) [2, 3, 4] in res
```
이 시점에서 foldl 은 `(0 + 1 / len, 0 + 1)` 이와 같은 식을 담은 튜플을 획득했다. (튜플 생성자에 의한 WHNF 만족)<br>
튜플에 원소는 반드시 평가된 값일 필요는 없고, 그 어디에서도 사용하지 않기 때문에 이 상태 그대로 재귀 호출을 이어간다.<br>
```
> let (res, len) = foldl (\(m, n) x -> (m + x / len, n + 1)) ((\(m, n) x -> (m + x / len, n + 1)) (0 + 1 / len, 0 + 1) 2) [3, 4] in res
> let (res, len) = foldl (\(m, n) x -> (m + x / len, n + 1)) (0 + 1 / len + 2 / len, 0 + 1 + 1) [3, 4] in res
> let (res, len) = foldl (\(m, n) x -> (m + x / len, n + 1)) ((\(m, n) x -> (m + x / len, n + 1)) (0 + 1 / len + 2 / len, 0 + 1 + 1) 3) [4] in res
> let (res, len) = foldl (\(m, n) x -> (m + x / len, n + 1)) (0 + 1 / len + 2 / len + 3 / len, 0 + 1 + 1 + 1) [4] in res
> let (res, len) = foldl (\(m, n) x -> (m + x / len, n + 1)) ((\(m, n) x -> (m + x / len, n + 1)) (0 + 1 / len + 2 / len + 3 / len, 0 + 1 + 1 + 1) 4) [] in res
> let (res, len) = foldl (\(m, n) x -> (m + x / len, n + 1)) (0 + 1 / len + 2 / len + 3 / len + 4 / len, 0 + 1 + 1 + 1 + 1) [] in res
```
이제 foldl은 인자로 제공 받은 리스트를 모두 비우고 패턴 매칭을 통해 `foldl _ v [] = v` 이 선택되어 튜플을 반환하게 된다.<br>
```
> let (res, len) = (0 + 1 / len + 2 / len + 3 / len + 4 / len, 0 + 1 + 1 + 1 + 1) in res
```
이제 let - in 구문과 패턴 매칭에 의해 튜플의 가장 왼쪽 원소가 선택되고 이제서야 하스켈은 튜플 내부의 식을 평가한다.<br>
헌데 이때 튜플 왼쪽 원소는 len 이라는 변수를 참조하고 있고 이는 튜플의 오른쪽 원소의 식인 `0 + 1 + 1 + 1 + 1` 평가를 선행하게 만든다.<br>
```
> let (res, len) = (0 + 1 / len + 2 / len + 3 / len + 4 / len, 4) in res
```
평가된 식은 다시 왼쪽 원소의 식을 평가하기 위해 다음과 같이 적용되고 최종 평가가 완료된다.
```
> let (res, len) = (0 + 1 / 4 + 2 / 4 + 3 / 4 + 4 / 4, 4) in res
> let (res, len) = (2.5, 4) in res
> 2.5
```

## 그래프 축약 (graph reduction)
적극 평가는 식의 평가가 즉시 이루어 지므로, 변수에 할당한 식은 즉시 값으로 1번 계산되며<br>
그 이후 변수를 사용하는 곳에서는 이 값을 계속 재 사용 한다.<br>
반면 하스켈은 지연 평가를 사용하므로 변수는 식은 실제 사용되기 전까지<br>
성크(thunk)의 형태로 유지되며 필요 시점에야 계산이 이루어진다.<br>
그런데 같은 형태의 식을 여러 곳에서 사용하고 있다면 이는 매우 비효율적 일 것이다.<br>
하스켈은 이 개선하기 위해 여러번 이용하는 것이 분명한 경우,<br>
그 평가를 첫 회에 대해서만 수행하고 나중에 필요할 때는 캐시된 결과를 제공하는 기법을 제공한다.<br>
하스켈의 순수성과 함께 함수간의 관계 그래프로 부터 캐시 사용 여부를 결정하는 기법으로<br>
그래프 축약(graph reduction) 이라고 한다.<br>

```
성크 (thunk)
하스켈에서는 필요할 때까지 평가를 하지 않는다.
이는 필연적으로 평가되지 않은 계산을 저장할 수단을 필요로 하게 된다.
그 저장 수단이 바로 성크(thunk) 이다.
계산 또는 평가가 예정되어 있는 식들은 성크(thunk)라는 객체 형태로 관리되며
평가가 완료 되었거나 더 이상 필요하지 않은 성크의 경우
Garbage Collector에 의해 제거된다.
```

## 지연 평가 / 적극 평가의 장점과 단점
마지막으로 지연 평가와 적극 평가의 장점과 단점을 정리하고 마치도록 하겠다.

### 지연평가
#### 장점
장점이라하기 미묘할 수도 있으나 생략에 의해 계산량을 줄일 수 있으며,<br> 
실행하지 않음 으로써 오류내성을 가진다.<br>
정의와 실행이 분리 됨으로써 자연스럽게 무한 자료구조나 무한 재귀를 만들수 있고,<br>
필요한 만큼 실행 함으로써 안전하게 무한을 다룰 수 있다.<br>

#### 단점
계산되지 않은 식에 대해 저장하기 위해 성크를 유지해야한다. (런타임 복잡도가 높다.)<br>
GC가 필수요소이다. (성크의 관리를 위해)<br>
디버깅과 최적화가 어렵다. (평가가 지연되므로 이를 추적하기 어렵다.)<br>

### 적극 평가
#### 장점
현재 컴퓨터 아키텍쳐는 레지스터와 메모리에 값을 싣고 <br>
다음으로 진행하는 형태로 최적화 및 실행 구조가 여기에 기반한다. <br>
적극 평가는 이런 구조에서 캐시 히트율 높이는데 유효하여, 현 컴퓨터 아키텍쳐와의 궁합이 좋다.<br>
계산하여야 할 식을 저장할 복잡한 구조가 필요없어 런타임이 단순하다.<br>
또한 인간이 이해하기 직관적인 구조라 성능 향상과 디버깅을 하기 쉽다.<br>

#### 단점
사용되지 않을지도 모르는 계산을 무조건하게 된다.<br>
멀티 스레드 환경에 취약하다.<br>
